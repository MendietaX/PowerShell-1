 <#
.SYNOPSIS
Get file version info from one or more computers.

.PARAMETER ComputerName
Specifies the computer(s) to get file version info on.

.PARAMETER FilePath
Specifies the file to query.

.PARAMETER InvokeParallel
Optional switch to Invoke-Command in parallel.

.PARAMETER IncludeError
Optional switch to include errors with InvokeParallel.

.INPUTS
String

.OUTPUTS
System.Object

.EXAMPLE
.\Get-FileVersion (Get-Content .\computers.txt) -FilePath 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'

.EXAMPLE
Get-Content .\computers.txt | .\Get-FileVersion -FilePath 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'

.EXAMPLE
.\Get-FileVersion (Get-Content .\computers.txt) -FilePath 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe' -InvokeParallel

.EXAMPLE
.\Get-FileVersion (Get-Content .\computers.txt) -FilePath 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe' -InvokeParallel -IncludeError

.NOTES
Author: Matthew D. Daugherty
Date Modified: 21 July 2020

#>

[CmdletBinding()]
param (

    # Mandatory parameter for one or more computer names
    [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)]
    [string[]]
    $ComputerName,

    # Mandatory parameter file path to query
    [Parameter(Mandatory)]
    [string]
    $FilePath,

    # Optional switch to Invoke-Command in parrallel
    [Parameter()]
    [switch]
    $InvokeParallel,

    # Optional switch to include errors with InvokeParallel
    [Parameter()]
    [switch]
    $IncludeError
)

begin {
    
    # Make sure InvokeParallel switch is not being used with piping input
    if ($InvokeParallel.IsPresent -and $MyInvocation.ExpectingInput) {

        Write-Warning 'Cannot accept pipeline input while using the InvokeParallel switch.'
        break
    }

    if ($ComputerName.Count -eq 1 -and $InvokeParallel.IsPresent) {

        Write-Warning 'The InvokeParallel switch cannot be used with only one computer name.'
        break
    }

    $FileName = Split-Path -Path $FilePath -Leaf

    $FilePathSplit = Split-Path -Path $FilePath -NoQualifier

    # Script block for Invoke-Command
    $InvokeCommandScriptBlock = {

        $VerbosePreference = $Using:VerbosePreference
        
        Write-Verbose "Querying $Using:FileName on $env:COMPUTERNAME"

        $Result = [PSCustomObject]@{

            FileExists = $false
            FileVersion = $null
            LastWriteTime = $null
        }

        if (Test-Path -Path $Using:FilePath) {

            $Result.FileExists = $true

            $File = Get-Item -Path $Using:FilePath

            $Result.FileVersion = $File.VersionInfo.FileVersionRaw

            $Result.LastWriteTime = $File.LastWriteTime
        }

        $Result

    } # end $InvokeCommandScriptBlock
}

process {

    switch ($InvokeParallel.IsPresent) {

        'False' {

            foreach ($Computer in $ComputerName) {

                $Result = [PSCustomObject]@{

                    ComputerName = $Computer.ToUpper()
                    TestConnection = $false
                    FileName = $null
                    FileExists = $null
                    FileVersion = $null
                    LastWriteTime = $null
                    Error = $null
                }

                if (Test-Connection -ComputerName $Computer -Count 1 -Quiet) {

                    $Result.TestConnection = $true

                    if (Test-Path -Path "\\$Computer\C$") {

                        if (Test-Path -Path "\\$Computer\C$\$FilePathSplit") {

                            $Result.FileName = $FileName

                            $Result.FileExists = $true

                            $File = Get-Item -Path "\\$Computer\C$\$FilePathSplit"

                            $Result.FileVersion = $File.VersionInfo.FileVersionRaw

                            $Result.LastWriteTime = $File.LastWriteTime

                        } # end if (Test-Path -Path "\\$Computer\C$\$FilePathSplit")
                        else {

                            $Result.FileName = $FileName

                            $Result.FileExists = $false
                        }

                    } # end if (Test-Path -Path "\\$Computer\C$")
                    else {

                        $InvokeCommandParams = @{

                            ComputerName = $Computer
                            ScriptBlock = $InvokeCommandScriptBlock
                            ErrorAction = 'Stop'
                        }

                        try {

                            $InvokeResult = Invoke-Command @InvokeCommandParams

                            $Result.FileName = $FileName

                            $Result.FileExists = $InvokeResult.FileExists

                            $Result.FileVersion = $InvokeResult.FileVersion

                            $Result.LastWriteTime = $InvokeResult.LastWriteTime
                        }
                        catch {

                            $Result.Error = $_.FullyQualifiedErrorId
                        }
                    }

                } # end if (Test-Connection)

                $Result

            } # end foreach ($Computer in $ComputerName)
        }
        'True' {

            # Parameters for Invoke-Command
            $InvokeCommandParams = @{

                ComputerName = $ComputerName
                ScriptBlock = $InvokeCommandScriptBlock
                ErrorAction = 'SilentlyContinue'
            }

            if ($IncludeError.IsPresent) {

                $InvokeCommandParams.Add('ErrorVariable','icmErrors')
            }

            Invoke-Command @InvokeCommandParams | ForEach-Object {

                [PSCustomObject]@{
        
                    ComputerName = $_.PSComputerName.ToUpper()
                    InvokeStatus = 'Success'
                    FileName = $FileName
                    FileExists = $_.FileExists
                    FileVersion = $_.FileVersion
                    LastWriteTime = $_.LastWriteTime
                }
            }

            if ($IncludeError.IsPresent) {

                if ($icmErrors) {
        
                    foreach ($icmError in $icmErrors) {
            
                        [PSCustomObject]@{
            
                            ComputerName = $icmError.TargetObject.ToUpper()
                            InvokeStatus = $icmError.FullyQualifiedErrorId
                            FileName = $null
                            Exists = $null
                            FileVersion = $null
                            LastWriteTime = $null
                        }
                    }
        
                } # end if ($icmErrors)
        
            } # end if ($IncludeError.IsPresent)
        }

    } # end switch ($InvokeParallel.IsPresent)
    
} # end process

end {}
